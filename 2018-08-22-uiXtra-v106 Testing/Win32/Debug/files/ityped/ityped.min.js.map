{"version":3,"file":"ityped.min.js","sources":["../src/ityped.js"],"sourcesContent":["/**\n * async foreach\n * https://www.npmjs.com/package/async-foreach\n */\n  const forEach = function (a, b, c) {\n    var d = -1,\n      e = a.length >>> 0;\n    (function f(g) {\n      var h,\n        j = g === !1;\n      do\n        ++d;\n      while (!(d in a) && d !== e);\n      if (j || d === e) {\n        c && c(!j, a);\n        return\n      }\n      g = b.call({\n        async: function () {\n          return h = !0,\n          f\n        }\n      }, a[d], d, a),\n      h || f(g)\n    })();\n  };\n\n\n/**\n * el is the element\n */\nlet selectedElement,\n  props,\n  /**\n  * creating the cursor\n  */\n  cursor = document.createElement('span');\n  cursor.classList.add('ityped-cursor');\n  cursor.textContent = '|';\n\n/**\n * @name setProps\n * @description Set the ityped properties configuration\n * @param {Object} config The configuration properties\n * @return {Promise}\n */\nfunction setProps ( config ) {\n  let props = config;\n  props.strings    = config.strings    || ['Put your string here...', 'and Enjoy!']\n  props.typeSpeed  = config.typeSpeed  || 100;\n  props.backSpeed  = config.backSpeed  || 50;\n  props.backDelay  = config.backDelay  || 500;\n  props.startDelay = config.startDelay || 500;\n  props.showCursor = config.showCursor;\n  props.loop       = config.loop       || false;\n\n  if (props.showCursor === undefined) props.showCursor = true;\n\n  return Promise.resolve(props);\n}\n/**\n * @name init\n * @param { String || Element } element The element that will receive the strings\n * @param {Object} config The initial configuration\n */\nfunction init(element, config) {\n  typeof element === 'string'\n    ? element = document.querySelector(element)\n    : element = element;\n  setProps(config).then(function(properties){\n    props = properties;\n    element._props = props;\n  // init cursor if needed\n  if (props.showCursor) {\n        initCursorOn(element, props.cursorChar || '|');\n  }\n    loopingOnWords(element);\n  })\n}\n\nfunction initCursorOn(element, cursorChar) {\n    const newCursor = cursor.cloneNode();\n  element.insertAdjacentElement('afterend', newCursor);\n    newCursor.textContent = cursorChar;\n}\n\n/**\n * @name loopingOnWords\n * @description Loop on each string passed\n * @param {HTMLElement} \telement \tThe element to handle the animation on\n * @param {Array} words The array that contain the words\n */\nfunction loopingOnWords(element) {\n  forEach(element._props.strings, function (word, index, arr) {\n    let time = (element._props.typeSpeed * word.length - 1);\n    /**\n     * set the correct time\n     * with the differences of type and back\n     * speed\n     */\n    if (element._props.backSpeed < element._props.typeSpeed) {\n      time -= (element._props.typeSpeed - element._props.backSpeed) * word.length;\n  } else if (element._props.backSpeed > element._props.typeSpeed) {\n      time += (element._props.backSpeed - element._props.typeSpeed) * word.length;\n    }\n    let done = this.async();\n    let len = element._props.strings.length;\n    iterateWords(element, word, index, len).then(function () {\n      setTimeout(function () {\n        done();\n      }, time)\n    })\n  }, function () {\n    if (element._props.loop) {\n      loopingOnWords(element);\n    }\n  });\n}\n/**\n * @name increment\n * @description Increment each letter and append it on element\n * @param {Element} element The Element that will receive the letters\n * @param {String} word The string that will be looped to\n * get each letter\n * @return {Promise}\n */\nfunction increment(element, word) {\n  return new Promise(function (resolve, reject) {\n      let count = 0;\n    for (let i = 0; i < word.length; i++) {\n      let wordIndex = i;\n      let len = word.length;\n      setTimeout(function (i) {\n        appendWord(element, word.charAt(wordIndex));\n        count++;\n        if (count === len - 1) {\n          resolve();\n        }\n      }, element._props.typeSpeed * i);\n    }\n  })\n}\n/**\n * @name appendWord\n * @description Append each letter on Element\n * @param {Element} element The Element that will receive the letter\n * @param {String} word The string that will be appended\n */\nfunction appendWord(element, word) {\n  element.innerHTML += word;\n}\n\n/**\n * @name iterateWords\n * @description Iterate on each word, incrementing and decrementing\n * @param {Element} element The Element that will receive the letters of word\n * @param {String} word The string that is the word\n * @param {Integer} index The index position of the words Array\n * @param {Integer} wordsLengthArray The length of words Array\n * @return {Promise}\n */\nfunction iterateWords(element, word, index, wordsLengthArray) {\n  return new Promise(function (resolve, reject) {\n    increment(element, word)\n      .then(function () {\n        setTimeout(function () {\n          decrement(element, word, index, wordsLengthArray)\n            .then(function () {\n              setTimeout(function(){\n                resolve();\n              }, element._props.startDelay)\n            });\n        }, element._props.backDelay)\n      });\n  });\n}\n/**\n * @name iterateInsideDecrement\n * @description Iterate on each word, inside the decrement function for decrement the word\n * @param {Element} element The Element that will receive the letters of word\n * @param {String} word The string that is the word\n * @param {Integer} len The length of words Array\n * @param {Promise} resolve The Promise.resolve method that will be trigerred when\n * the decrement iteration are finished\n * @return {Promise}\n */\nfunction iterateInsideDecrement(element, word, len, resolve) {\n  for (let i = len; i > 0; i--) {\n    let iteratedI = i, count = len;\n    setTimeout(function (i) {\n      element.innerHTML = word.substring(0, len - iteratedI)\n      count--;\n      if (iteratedI === 1) {\n        resolve();\n      }\n    }, element._props.backSpeed * i);\n  }\n}\n\n/**\n * @name decrement\n * @description decrement the word in the correct case\n * @param {Element} element The Element that will receive the letters of word\n * @param {String} word The string that is the word\n * @param {Integer} index The index of the Array that contain the word\n * @param {Integer} lengthWords The length of words Array\n */\nfunction decrement(element, word, index, lengthWords) {\n  return new Promise(function (resolve, reject) {\n    let len = word.length;\n    // if is the last letter and the last word and no loop\n    if (index + 1 === lengthWords) {\n      if (!element._props.loop) {\n      // when the last word\n        if (element._props.onFinished !== undefined && typeof element._props.onFinished === \"function\"){\n            element._props.onFinished();\n        }\n        element.innerHTML = word;\n      }\n      else if (element._props.loop) {\n        iterateInsideDecrement(element, word, len, resolve);\n      }\n    } else if (index + 1 !== lengthWords) {\n      iterateInsideDecrement(element, word, len, resolve);\n    }\n  })\n}\n\n/**\n * @name destroy\n * @description destroy the onFinished function\n */\nfunction destroy (element) {\n  element._props.onFinished = function(){return void 0};\n}\n\n/**\n * Return the init function\n */\nexport { init, destroy };\n"],"names":["setProps","config","props","strings","typeSpeed","backSpeed","backDelay","startDelay","showCursor","loop","undefined","Promise","resolve","init","element","document","querySelector","then","properties","_props","cursorChar","initCursorOn","newCursor","cursor","cloneNode","insertAdjacentElement","textContent","loopingOnWords","word","index","arr","time","length","done","this","async","len","increment","reject","count","i","wordIndex","charAt","appendWord","innerHTML","iterateWords","wordsLengthArray","iterateInsideDecrement","iteratedI","substring","decrement","lengthWords","onFinished","destroy","forEach","a","b","c","d","e","f","g","h","j","call","createElement","classList","add"],"mappings":"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"}